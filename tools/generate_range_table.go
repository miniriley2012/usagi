package main

import (
	"bufio"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"io"
	"maps"
	"math"
	"os"
	"regexp"
	"slices"
	"strconv"
	"strings"
	"unicode"

	"golang.org/x/text/unicode/rangetable"
)

func main() {
	inputPaths := os.Args[1:]

	output := &Output{Tables: map[string][]*unicode.RangeTable{}}

	for _, path := range inputPaths {
		f, err := os.Open(path)
		if err != nil {
			panic(err)
		}
		defer f.Close()

		err = readInputFile(output, f)
		if err != nil {
			panic(err)
		}
	}

	tables := map[string]*unicode.RangeTable{}
	for key, tbls := range output.Tables {
		tables[key] = rangetable.Merge(tbls...)
	}

	keys := slices.Sorted(maps.Keys(tables))

	specs := make([]ast.Spec, 0, len(keys))

	for _, key := range keys {
		specs = append(specs, &ast.ValueSpec{
			Names:  []*ast.Ident{ast.NewIdent(key)},
			Values: []ast.Expr{rangeTableToExpr(tables[key])},
		})
	}

	f := &ast.File{Name: ast.NewIdent("scanner")}

	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok: token.IMPORT,
		Specs: []ast.Spec{&ast.ImportSpec{Path: &ast.BasicLit{
			Kind:  token.STRING,
			Value: "\"unicode\"",
		}}},
	})

	f.Decls = append(f.Decls, &ast.GenDecl{
		Tok:    token.VAR,
		Lparen: 1,
		Specs:  specs,
		Rparen: 1,
	})

	fmt.Println("// Code generated by generate_range_table.go\n")

	err := format.Node(os.Stdout, token.NewFileSet(), f)
	if err != nil {
		panic(err)
	}
}

func rangeTableToExpr(tbl *unicode.RangeTable) ast.Expr {
	r16s := make([]ast.Expr, 0, len(tbl.R16))
	r32s := make([]ast.Expr, 0, len(tbl.R32))

	for _, r := range tbl.R16 {
		r16s = append(r16s, r16ToExpr(&r))
	}
	for _, r := range tbl.R32 {
		r32s = append(r32s, r32ToExpr(&r))
	}

	return &ast.CompositeLit{
		Type: &ast.SelectorExpr{
			X:   ast.NewIdent("unicode"),
			Sel: ast.NewIdent("RangeTable"),
		},
		Elts: []ast.Expr{
			&ast.KeyValueExpr{
				Key: ast.NewIdent("R16"),
				Value: &ast.CompositeLit{
					Type: &ast.ArrayType{Elt: &ast.SelectorExpr{
						X:   ast.NewIdent("unicode"),
						Sel: ast.NewIdent("Range16"),
					}},
					Elts: r16s,
				},
			},
			&ast.KeyValueExpr{
				Key: ast.NewIdent("R32"),
				Value: &ast.CompositeLit{
					Type: &ast.ArrayType{Elt: &ast.SelectorExpr{
						X:   ast.NewIdent("unicode"),
						Sel: ast.NewIdent("Range32"),
					}},
					Elts: r32s,
				},
			},
			&ast.KeyValueExpr{
				Key: ast.NewIdent("LatinOffset"),
				Value: &ast.BasicLit{
					Kind:  token.INT,
					Value: strconv.FormatInt(int64(tbl.LatinOffset), 10),
				},
			},
		},
	}
}

func r16ToExpr(tbl *unicode.Range16) ast.Expr {
	return &ast.CompositeLit{
		Elts: []ast.Expr{
			&ast.KeyValueExpr{
				Key: ast.NewIdent("Lo"),
				Value: &ast.BasicLit{
					Kind:  token.INT,
					Value: "0x" + strconv.FormatUint(uint64(tbl.Lo), 16),
				},
			},
			&ast.KeyValueExpr{
				Key: ast.NewIdent("Hi"),
				Value: &ast.BasicLit{
					Kind:  token.INT,
					Value: "0x" + strconv.FormatUint(uint64(tbl.Hi), 16),
				},
			},
			&ast.KeyValueExpr{
				Key: ast.NewIdent("Stride"),
				Value: &ast.BasicLit{
					Kind:  token.INT,
					Value: "0x" + strconv.FormatUint(uint64(tbl.Stride), 16),
				},
			},
		},
	}
}

func r32ToExpr(tbl *unicode.Range32) ast.Expr {
	return &ast.CompositeLit{
		Elts: []ast.Expr{
			&ast.BasicLit{
				Kind:  token.INT,
				Value: "0x" + strconv.FormatUint(uint64(tbl.Lo), 16),
			},
			&ast.BasicLit{
				Kind:  token.INT,
				Value: "0x" + strconv.FormatUint(uint64(tbl.Hi), 16),
			},
			&ast.BasicLit{
				Kind:  token.INT,
				Value: "0x" + strconv.FormatUint(uint64(tbl.Stride), 16),
			},
		},
	}
}

var trimComment = regexp.MustCompile("#.+")

func readInputFile(output *Output, rd io.Reader) error {
	buf := bufio.NewReader(rd)

	type Range struct {
		Low  uint32
		High uint32
	}

	ranges := map[string][]Range{}

	for {
		line, err := buf.ReadString('\n')
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			return err
		}

		line = trimComment.ReplaceAllLiteralString(line, "")

		rng, name, found := strings.Cut(line, ";")
		if !found {
			continue
		}
		rng = strings.TrimSpace(rng)
		name = strings.TrimSpace(name)

		low, high, found := strings.Cut(rng, "..")
		if found {
			lowValue, err := strconv.ParseUint(low, 16, 32)
			if err != nil {
				return err
			}
			highValue, err := strconv.ParseUint(high, 16, 32)
			if err != nil {
				return err
			}
			ranges[name] = append(ranges[name], Range{uint32(lowValue), uint32(highValue)})
		} else {
			lowValue, err := strconv.ParseUint(low, 16, 32)
			if err != nil {
				return err
			}
			ranges[name] = append(ranges[name], Range{uint32(lowValue), uint32(lowValue)})
		}
	}

	for name, rs := range ranges {
		tbl := &unicode.RangeTable{}
		for _, r := range rs {
			if r.Low > math.MaxUint16 {
				tbl.R32 = append(tbl.R32, unicode.Range32{
					Lo:     r.Low,
					Hi:     r.High,
					Stride: 1,
				})
			} else {
				// Handle split across uint16 range
				if r.High > math.MaxUint16 {
					tbl.R16 = append(tbl.R16, unicode.Range16{
						Lo:     uint16(r.Low),
						Hi:     math.MaxUint16,
						Stride: 1,
					})
					tbl.R32 = append(tbl.R32, unicode.Range32{
						Lo:     math.MaxUint16,
						Hi:     r.High,
						Stride: 1,
					})
				} else {
					tbl.R16 = append(tbl.R16, unicode.Range16{
						Lo:     uint16(r.Low),
						Hi:     uint16(r.High),
						Stride: 1,
					})
				}
			}
		}
		output.Tables[name] = append(output.Tables[name], tbl)
	}

	return nil
}

type Output struct {
	Tables map[string][]*unicode.RangeTable
}
